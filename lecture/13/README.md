関数名の変更
+ クリックへの反応→人が一手進める
+ そろった場所を目立たせる→画面を更新する

# ランダムマルバツ

## 乱数

JavaScriptには，0以上1未満の乱数を返す`Math.random()`が用意されている。

これと，小数点以下を切り捨てる`Math.floor`を組み合わせると，利用して0からnまでの整数を得られるようになる（コンソールで試してみよう）。

```
console.log(Math.floor(Math.random() * 9));
```

## COMとの対戦

ゲームの流れは次のようになる。

1. 人が一手進める。
1. 勝敗が決まったかどうかをチェックする。決まったら終わり。
1. COMが一手進める。
1. 勝敗が決まったかどうかをチェックする。決まったら終わり。
1. 1に戻る。

### 手番の記憶

```
var 人 = 1;//先手ということ
var COM = -1;//後手ということ
```

### 人が一手進める

```
function 人が一手進める(位置) {
  盤面[位置] = 人;
  if (人 == 1) {
    $('#セル' + 位置).addClass('○');
  } else {
    $('#セル' + 位置).addClass('×');
  }
  画面を更新する();
  COMが一手進める();
}
```

### 配列内の要素の検索

```
var 配列 = [3, 4, 0, 1, 2];
console.log(配列.indexOf(1));
console.log(配列.indexOf(5));
```

### COMが一手進める

`セル数`を記憶しておく（グローバル変数）。

```
var セル数 = 盤面.length;
```

```
function COMが一手進める() {
  空白がないなら終了//引き分け
  終わっていたら終了//人の勝ち

  ランダムに位置を決める
  埋まっていたらやり直し

  COMの一手とする
  画面を更新する
}
```

「終わった」フラグを立てる。（`$('.終').length != 0`として確認することもできる。）

```
function 画面を更新する() {
  for (var i = 0; i < 筋の数; ++i) {
    var 結果 = そろったか(筋の配列[i]);
    if (結果 !== 0) {
      $('div').addClass('終');
      筋に勝印を付ける(筋の配列[i]);
      終わった = true;
    }
  }
}
```

```
function COMが一手進める() {
  if (盤面.indexOf(0) == -1) {//空白がなかったら強制終了
    return;
  }
  if (終わった) {//終わってたら強制終了
    return;
  }
  var 位置 = Math.floor(Math.random() * 9);
  if (盤面[位置] != 0) {//埋まっていたら
    COMが一手進める();//やり直し
    return;//ここで終わり。この先には進まない
  }

  盤面[位置] = COM;
  if (COM == 1) {//先手なら
    $('#セル' + 位置).addClass('○');
  } else {//後手なら
    $('#セル' + 位置).addClass('×');
  }
  console.log(盤面);
  画面を更新する();
}
```

これで，人間が先手版の場合は完成。

### ゲーム開始時に先手・後手をランダムに決める

```
function 初期設定() {//50%の確率で先手後手を入れ替える
  if (Math.random() < 0.5) {
    人 = -1;
    COM = 1;
    COMが一手進める();
  }  
}
```

この関数を直接呼び出してもうまくいかない。（HTMLの準備が終わっていないから。）

ページの準備ができたら実行する。

```
$(window.document).ready(初期設定);
```
